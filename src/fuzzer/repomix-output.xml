This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
harness/
  linux/
    generator.nim
  mappings/
    build_top.nim
    expr_map.nim
    rule_chain_table.nim
    serialize.nim
    util.nim
  mnl/
    generator.nim
  nftnl/
    attrs/
      expr/
        all.nim
        bitwise.nim
        cmp.nim
        counter.nim
        ct.nim
        immediate.nim
        limit.nim
        meta.nim
        payload.nim
        quota.nim
      chain.nim
      rule.nim
      table.nim
    raii/
      basics.nim
      expresions.nim
      generator.nim
      iterators.nim
    helpers.nim
  export_fuzz.nim
  harness.nim
  mappings.nim
  messageBuilder.nim
  proto_raw.nim
mutator/
  lpm_consumer.cpp
schema/
  elaborate.proto
tests/
  bench/
    bench_table.nim
  config.nims
  core_chain.nim
  core_expr.nim
  core_raii.nim
  core_rule.nim
  core_table.nim
  integration_build.nim
  integration_expr.nim
  integration_log.nim
  integration_mapping.nim
  integration_sanitize.nim
  integration_snprintf.nim
  test_all.nim
  test_core.nim
  test_integration.nim
.gitignore
devshells.nix
harness.nimble
installables.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="harness/linux/generator.nim">
# src/linux/generator.nim
{.passC: staticExec("pkg-config --cflags libnftnl").}
{.passL: staticExec("pkg-config --libs   libnftnl").}

from os import parentDir, `/`
import futhark, os

when defined(useFuthark):
  const
    glibcInclude = staticExec("nix eval --raw nixpkgs#glibc.dev.outPath") & "/include"
    linuxHeadersInclude =
      staticExec("nix build --no-link --print-out-paths nixpkgs#linuxHeaders") &
      "/include"

    outDir = currentSourcePath.parentDir / "autogenerated"
    outFile = outDir / "generated_linux.nim"

  static:
    if not dirExists(outDir):
      createDir(outDir)

  importc:
    outputPath outFile.string

    # Add both libc + kernel headers
    path glibcInclude
    path linuxHeadersInclude

    "linux/socket.h"
    "sys/socket.h"
    "linux/netlink.h"
    "linux/netfilter.h" # <--- now present in linuxHeaders
    "linux/netfilter/nf_tables.h"
    "linux/netfilter/nfnetlink.h"
    "linux/netfilter_ipv4.h"
    "linux/netfilter_ipv6.h"
</file>

<file path="harness/mappings/build_top.nim">
# mappings/build_top.nim
import ../proto_raw as pbraw
import ../nftnl/raii/basics
import ./rule_chain_table
import ./serialize
import ./util

proc buildTop*(x: pbraw.Top): seq[seq[uint8]] =
  result = @[]
  var seqNum: uint32 = 1
  for tpb in x.tables:
    let t = toNftnlTable(tpb)
    result.add serializeTableWithNewNlMsg(t, seqNum)
    seqNum.inc
    for cpb in tpb.chains:
      let c = toNftnlChain(cpb)
      result.add serializeChainWithNewNlMsg(c, seqNum)
      seqNum.inc
      for rpb in cpb.rules:
        let r = toNftnlRule(rpb)
        result.add serializeRuleWithNewNlMsg(r, seqNum)
        seqNum.inc
</file>

<file path="harness/mappings/expr_map.nim">
# mappings/expr_map.nim
import ../proto_raw as pbraw
import ../nftnl/raii/expresions
import
  ../nftnl/attrs/expr/
    [all, cmp, payload, meta, bitwise, immediate, counter, ct, limit, quota]
import ./util

proc toNftnlExpr*(x: pbraw.Expr): expresions.Expression =
  var e: expresions.Expression

  case ord(x.`type`)
  of 1: # payload
    e = expresions.Expression(expresions.PayloadExpr.create())
    setU32(toRaw(e), payload.idPayloadDreg, x.dreg)
    setU32(toRaw(e), payload.idPayloadBase, x.base)
    setU32(toRaw(e), payload.idPayloadOffset, x.offset)
    setU32(toRaw(e), payload.idPayloadLen, x.len)
    if x.csum_type != 0'u32:
      setU32(toRaw(e), payload.idPayloadCsumType, x.csum_type)
    if x.csum_offset != 0'u32:
      setU32(toRaw(e), payload.idPayloadCsumOffset, x.csum_offset)
    if x.csum_flags != 0'u32:
      setU32(toRaw(e), payload.idPayloadFlags, x.csum_flags)
  of 2: # cmp
    e = expresions.Expression(expresions.CmpExpr.create())
    setU32(toRaw(e), cmp.idCmpSreg, x.sreg)
    setU32(toRaw(e), cmp.idCmpOp, x.op)
    if x.data.len > 0:
      setBlob(toRaw(e), cmp.idCmpData, x.data)
  of 3: # meta
    e = expresions.Expression(expresions.MetaExpr.create())
    setU32(toRaw(e), meta.idMetaKey, x.key)
    if x.sreg != 0'u32:
      setU32(toRaw(e), meta.idMetaSreg, x.sreg)
    if x.dreg != 0'u32:
      setU32(toRaw(e), meta.idMetaDreg, x.dreg)
    if x.str.len > 0:
      setStr(toRaw(e), meta.idMetaSreg, x.str)
  of 4: # bitwise
    e = expresions.Expression(expresions.BitwiseExpr.create())
    setU32(toRaw(e), bitwise.idBitwiseSreg, x.sreg)
    setU32(toRaw(e), bitwise.idBitwiseDreg, x.dreg)
    setU32(toRaw(e), bitwise.idBitwiseLen, x.len)
    if x.op != 0'u32:
      setU32(toRaw(e), bitwise.idBitwiseOp, x.op)
    if x.mask.len > 0:
      setBlob(toRaw(e), bitwise.idBitwiseMask, x.mask)
    if x.xor.len > 0:
      setBlob(toRaw(e), bitwise.idBitwiseXor, x.xor)
    if x.data.len > 0:
      setBlob(toRaw(e), bitwise.idBitwiseData, x.data)
  of 5: # immediate
    e = expresions.Expression(expresions.ImmediateExpr.create())
    if x.dreg != 0'u32:
      setU32(toRaw(e), immediate.idImmDreg, x.dreg)
    if x.data.len > 0:
      setBlob(toRaw(e), immediate.idImmData, x.data)
    elif x.verdict != 0'u32:
      setU32(toRaw(e), immediate.idImmVerdict, x.verdict)
      if x.chain.len > 0:
        setStr(toRaw(e), immediate.idImmChain, x.chain)
      if x.chain_id != 0'u32:
        when declared(immediate.idImmChainId):
          setU32(toRaw(e), immediate.idImmChainId, x.chain_id)
  of 6: # counter
    e = expresions.Expression(expresions.CounterExpr.create())
  of 7: # ct (conntrack)
    e = expresions.Expression(expresions.CtExpr.create())
    if x.key != 0'u32:
      setU32(toRaw(e), ct.idCtKey, x.key)
    if x.dreg != 0'u32:
      setU32(toRaw(e), ct.idCtDreg, x.dreg)
    if x.op != 0'u32:
      setU32(toRaw(e), ct.idCtDir, x.op)
  of 8: # limit
    e = expresions.Expression(expresions.LimitExpr.create())
    if x.base != 0'u32:
      setU32(toRaw(e), limit.idLimitRate, x.base)
    if x.len != 0'u32:
      setU32(toRaw(e), limit.idLimitUnit, x.len)
    if x.op != 0'u32:
      setU32(toRaw(e), limit.idLimitBurst, x.op)
    if x.key != 0'u32:
      setU32(toRaw(e), limit.idLimitType, x.key)
    if x.attr_mask != 0'u32:
      setU32(toRaw(e), limit.idLimitFlags, x.attr_mask)
  of 9: # quota
    e = expresions.Expression(expresions.QuotaExpr.create())
    if x.base != 0'u32:
      setU64(toRaw(e), quota.idQuotaBytes, uint64(x.base))
    if x.op != 0'u32:
      setU32(toRaw(e), quota.idQuotaFlags, x.op)
  else:
    dbg "      [warn] unknown/unsupported expr type=" & $ord(x.`type`)
    return expresions.Expression()

  e
</file>

<file path="harness/mappings/rule_chain_table.nim">
import ../proto_raw as pbraw
import ../nftnl/autogenerated/generated_nftnl as gen_nftnl
import ../linux/autogenerated/generated_linux as gen_linux
import ../nftnl/raii/[basics, expresions]
import ../nftnl/attrs/[rule, chain, table]
import ./expr_map
import ./util
import ../messageBuilder

# Important, this is what adds rules
proc toNftnlRule*(x: pbraw.Rule): basics.Rule =
  let r = basics.Rule.create()
  r.family = x.family
  r.table = x.table
  r.chain = x.chain
  dbg "    â†’ Rule(family=" & $x.family & ", table=" & x.table & ", chain=" & x.chain &
    ")"
  for ex in x.exprs:
    let e = toNftnlExpr(ex)
    if e.raw.isNil:
      dbg "      [skip] invalid expr; not adding"
      continue
    addExpr(r, e)
  r

proc toNftnlChain*(x: pbraw.Chain): basics.Chain =
  let c = basics.Chain.create()
  c.family = x.family
  c.table = x.table
  c.name = x.name
  c.typeName = x.`type`
  c.hooknum = x.hook
  c.prio = x.prio.uint32
  c.policy = x.policy
  dbg "  â†’ Chain(" & x.name & ") table=" & x.table
  for r in x.rules:
    discard toNftnlRule(r)
  c

proc toNftnlTable*(x: pbraw.Table): basics.Table =
  let t = basics.Table.create()
  t.family = x.family
  t.name = x.name
  dbg "â†’ Table(" & x.name & ") family=" & $x.family
  for ch in x.chains:
    discard toNftnlChain(ch)
  t
</file>

<file path="harness/mappings/serialize.nim">
# mappings/serialize.nim
import ../nftnl/raii/[basics]
import ../nftnl/attrs/[rule, chain, table]
import ../messageBuilder

const
  NFT_MSG_NEWTABLE* = 0x10'u32
  NFT_MSG_NEWCHAIN* = 0x11'u32
  NFT_MSG_NEWRULE* = 0x12'u32
  NLM_F_CREATE* = 0x400'u32
  NLM_F_EXCL* = 0x200'u32
  NLM_F_ACK* = 0x4'u32

proc serializeTableWithNewNlMsg*(t: basics.Table, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWTABLE.cint,
    t.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildTableMsg(nlh, t)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)

proc serializeChainWithNewNlMsg*(c: basics.Chain, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWCHAIN.cint,
    c.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildChainMsg(nlh, c)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)

proc serializeRuleWithNewNlMsg*(r: basics.Rule, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWRULE.cint,
    r.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildRuleMsg(nlh, r)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)
</file>

<file path="harness/mappings/util.nim">
# mappings/util.nim

when defined(DEBUG_MAPPING):
  proc dbg*(msg: string) =
    echo msg

else:
  template dbg*(msg: string) =
    discard

proc toU32Le*(b: openArray[uint8]): uint32 =
  case b.len
  of 0:
    0'u32
  of 1:
    uint32(b[0])
  of 2:
    uint32(b[0]) or (uint32(b[1]) shl 8)
  else:
    uint32(b[0]) or (uint32(b[1]) shl 8) or (uint32(b[2]) shl 16) or
      (uint32(b[3]) shl 24)

proc bytesToStr*(b: seq[uint8]): string =
  if b.len == 0:
    return ""
  result = newString(b.len)
  for i in 0 ..< b.len:
    result[i] = char(b[i])

template has*(mask: uint32, bit: int): bool =
  (mask and (1'u32 shl bit)) != 0
</file>

<file path="harness/mnl/generator.nim">
{.passC: staticExec("pkg-config --cflags libmnl").}
{.passL: staticExec("pkg-config --libs   libmnl").}

from os import parentDir, `/`
import futhark, os

when defined(useFuthark):
  const
    glibcInclude = staticExec("nix eval --raw nixpkgs#glibc.dev.outPath") & "/include"
    mnlInclude = staticExec("pkg-config --variable=includedir libmnl")
    outDir = currentSourcePath.parentDir / "autogenerated"
    outFile = outDir / "generated_mnl.nim"

  static:
    if not dirExists(outDir):
      createDir(outDir)

  importc:
    outputPath outFile.string
    path glibcInclude
    path mnlInclude

    # Core libmnl API
    "libmnl/libmnl.h"
</file>

<file path="harness/nftnl/attrs/expr/all.nim">
import ../../autogenerated/generated_nftnl
import ../../raii/expresions

# --- Getters ---------------------------------------------------------------
proc getU32*(p: ptr struct_nftnl_expr, attr: uint16): uint32 =
  nftnl_expr_get_u32(p, attr)

proc getU64*(p: ptr struct_nftnl_expr, attr: uint16): uint64 =
  ## Retrieve a 64-bit unsigned attribute value.
  nftnl_expr_get_u64(p, attr)

proc getStr*(p: ptr struct_nftnl_expr, attr: uint16): string =
  $cast[cstring](nftnl_expr_get_str(p, attr))

proc getBlob*(p: ptr struct_nftnl_expr, attr: uint16): seq[uint8] =
  var size: uint32
  let data = nftnl_expr_get(p, attr, addr size)
  if data.isNil or size == 0:
    return @[]
  result = newSeq[uint8](int(size))
  copyMem(addr result[0], data, size)

# --- Setters ---------------------------------------------------------------
proc setU32*(p: ptr struct_nftnl_expr, attr: uint16, v: uint32) =
  nftnl_expr_set_u32(p, attr, v)

proc setU64*(p: ptr struct_nftnl_expr, attr: uint16, v: uint64) =
  ## Set a 64-bit unsigned attribute value.
  nftnl_expr_set_u64(p, attr, v)

proc setStr*(p: ptr struct_nftnl_expr, attr: uint16, v: string) =
  discard nftnl_expr_set_str(p, attr, cast[ptr uint8](v.cstring))

proc setBlob*(p: ptr struct_nftnl_expr, attr: uint16, v: seq[uint8]) =
  if v.len > 0:
    discard nftnl_expr_set(p, attr, unsafeAddr v[0], uint32(v.len))
  else:
    discard nftnl_expr_set(p, attr, nil, 0)
</file>

<file path="harness/nftnl/attrs/expr/bitwise.nim">
# ===========================================================================
# ðŸ§© nftnl "bitwise" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32, getBlob, setBlob

# ---------------------------------------------------------------------------
# Attribute IDs (mirroring libnftnl bitwise_attr_policy)
# ---------------------------------------------------------------------------
const
  idBitwiseSreg* = uint16(NFTNL_EXPR_BITWISE_SREG)
  idBitwiseDreg* = uint16(NFTNL_EXPR_BITWISE_DREG)
  idBitwiseLen* = uint16(NFTNL_EXPR_BITWISE_LEN)
  idBitwiseMask* = uint16(NFTNL_EXPR_BITWISE_MASK)
  idBitwiseXor* = uint16(NFTNL_EXPR_BITWISE_XOR)
  idBitwiseOp* = uint16(NFTNL_EXPR_BITWISE_OP)
  idBitwiseData* = uint16(NFTNL_EXPR_BITWISE_DATA)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc sreg*(e: BitwiseExpr): uint32 =
  getU32(toRaw(e), idBitwiseSreg)

proc `sreg=`*(e: BitwiseExpr, v: uint32) =
  setU32(toRaw(e), idBitwiseSreg, v)

proc dreg*(e: BitwiseExpr): uint32 =
  getU32(toRaw(e), idBitwiseDreg)

proc `dreg=`*(e: BitwiseExpr, v: uint32) =
  setU32(toRaw(e), idBitwiseDreg, v)

proc len*(e: BitwiseExpr): uint32 =
  getU32(toRaw(e), idBitwiseLen)

proc `len=`*(e: BitwiseExpr, v: uint32) =
  setU32(toRaw(e), idBitwiseLen, v)

proc mask*(e: BitwiseExpr): seq[uint8] =
  getBlob(toRaw(e), idBitwiseMask)

proc `mask=`*(e: BitwiseExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idBitwiseMask, v)

proc `xor`*(e: BitwiseExpr): seq[uint8] =
  getBlob(toRaw(e), idBitwiseXor)

proc `xor=`*(e: BitwiseExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idBitwiseXor, v)

proc op*(e: BitwiseExpr): uint32 =
  getU32(toRaw(e), idBitwiseOp)

proc `op=`*(e: BitwiseExpr, v: uint32) =
  setU32(toRaw(e), idBitwiseOp, v)

proc data*(e: BitwiseExpr): seq[uint8] =
  getBlob(toRaw(e), idBitwiseData)

proc `data=`*(e: BitwiseExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idBitwiseData, v)
</file>

<file path="harness/nftnl/attrs/expr/cmp.nim">
import ../../autogenerated/generated_nftnl
import ../../../linux/autogenerated/generated_linux # for enum_nft_cmp_ops
import ../../raii/expresions
import ./all # getU32, getBlob, setU32, setBlob

# ---------------------------------------------------------------------------
# nftnl "cmp" expression attribute accessors
# ---------------------------------------------------------------------------

const
  idCmpSreg* = uint16(NFTNL_EXPR_CMP_SREG)
  idCmpOp* = uint16(NFTNL_EXPR_CMP_OP)
  idCmpData* = uint16(NFTNL_EXPR_CMP_DATA)

# --- ergonomic field-like accessors ----------------------------------------

proc sreg*(e: CmpExpr): uint32 =
  ## Source register for compare expression.
  getU32(toRaw(e), idCmpSreg)

proc `sreg=`*(e: CmpExpr, v: uint32) =
  setU32(toRaw(e), idCmpSreg, v)

proc op*(e: CmpExpr): enum_nft_cmp_ops =
  ## Comparison operator (==, !=, <, etc.)
  enum_nft_cmp_ops(getU32(toRaw(e), idCmpOp))

proc `op=`*(e: CmpExpr, v: enum_nft_cmp_ops) =
  setU32(toRaw(e), idCmpOp, v.uint32)

proc data*(e: CmpExpr): seq[uint8] =
  ## Raw byte sequence representing the constant being compared.
  getBlob(toRaw(e), idCmpData)

proc `data=`*(e: CmpExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idCmpData, v)
</file>

<file path="harness/nftnl/attrs/expr/counter.nim">
# ===========================================================================
# ðŸ§© nftnl "counter" expression attribute accessors
# ===========================================================================

import std/sequtils
import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getBlob, setBlob

# ---------------------------------------------------------------------------
# Attribute IDs (match libnftnl counter_attr_policy)
# ---------------------------------------------------------------------------
const
  idCtrPackets* = uint16(NFTNL_EXPR_CTR_PACKETS)
  idCtrBytes* = uint16(NFTNL_EXPR_CTR_BYTES)

# ---------------------------------------------------------------------------
# Helper procs for raw uint64 <-> seq[uint8] conversion
# ---------------------------------------------------------------------------

proc toBytes64*(v: uint64): seq[uint8] =
  ## Convert a uint64 into a raw 8-byte buffer (host-endian).
  result = newSeqWith(8, 0'u8)
  copyMem(addr result[0], unsafeAddr v, 8)

proc fromBytes64*(buf: openArray[uint8]): uint64 =
  ## Convert an 8-byte raw buffer into a uint64 (host-endian).
  if buf.len < 8:
    return 0'u64
  copyMem(addr result, unsafeAddr buf[0], 8)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc packets*(e: CounterExpr): uint64 =
  ## Number of packets seen by this counter.
  fromBytes64(getBlob(toRaw(e), idCtrPackets))

proc `packets=`*(e: CounterExpr, v: uint64) =
  setBlob(toRaw(e), idCtrPackets, toBytes64(v))

proc bytes*(e: CounterExpr): uint64 =
  ## Number of bytes seen by this counter.
  fromBytes64(getBlob(toRaw(e), idCtrBytes))

proc `bytes=`*(e: CounterExpr, v: uint64) =
  setBlob(toRaw(e), idCtrBytes, toBytes64(v))
</file>

<file path="harness/nftnl/attrs/expr/ct.nim">
# ===========================================================================
# ðŸ§© nftnl "ct" (connection tracking) expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32

# ---------------------------------------------------------------------------
# Attribute IDs (mirroring libnftnl ct_attr_policy)
# ---------------------------------------------------------------------------
const
  idCtKey* = uint16(NFTNL_EXPR_CT_KEY)
  idCtDreg* = uint16(NFTNL_EXPR_CT_DREG)
  idCtDir* = uint16(NFTNL_EXPR_CT_DIR) # optional, direction selector

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc key*(e: CtExpr): uint32 =
  ## Which conntrack field (NFT_CT_STATE, NFT_CT_MARK, NFT_CT_ZONE, etc.)
  getU32(toRaw(e), idCtKey)

proc `key=`*(e: CtExpr, v: uint32) =
  setU32(toRaw(e), idCtKey, v)

proc dreg*(e: CtExpr): uint32 =
  ## Destination register to store CT field value
  getU32(toRaw(e), idCtDreg)

proc `dreg=`*(e: CtExpr, v: uint32) =
  setU32(toRaw(e), idCtDreg, v)

proc dir*(e: CtExpr): uint32 =
  ## Direction (ORIG = 0, REPLY = 1)
  getU32(toRaw(e), idCtDir)

proc `dir=`*(e: CtExpr, v: uint32) =
  setU32(toRaw(e), idCtDir, v)
</file>

<file path="harness/nftnl/attrs/expr/immediate.nim">
# ===========================================================================
# ðŸ§© nftnl "immediate" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32, getBlob, setBlob, getStr, setStr

# ---------------------------------------------------------------------------
# Attribute IDs
# ---------------------------------------------------------------------------
const
  idImmDreg* = uint16(NFTNL_EXPR_IMM_DREG)
  idImmData* = uint16(NFTNL_EXPR_IMM_DATA)
  idImmVerdict* = uint16(NFTNL_EXPR_IMM_VERDICT)
  idImmChain* = uint16(NFTNL_EXPR_IMM_CHAIN)
  idImmChainId* = uint16(NFTNL_EXPR_IMM_CHAIN_ID)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc dreg*(e: ImmediateExpr): uint32 =
  ## Destination register to load the immediate value into.
  getU32(toRaw(e), idImmDreg)

proc `dreg=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmDreg, v)

proc data*(e: ImmediateExpr): seq[uint8] =
  ## Constant byte data for the immediate expression.
  getBlob(toRaw(e), idImmData)

proc `data=`*(e: ImmediateExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idImmData, v)

proc verdict*(e: ImmediateExpr): uint32 =
  ## Numeric verdict (NF_ACCEPT, NF_DROP, NF_JUMP, etc.)
  getU32(toRaw(e), idImmVerdict)

proc `verdict=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmVerdict, v)

proc chain*(e: ImmediateExpr): string =
  ## Optional chain name (used when verdict == NF_JUMP / NF_GOTO).
  getStr(toRaw(e), idImmChain)

proc `chain=`*(e: ImmediateExpr, v: string) =
  setStr(toRaw(e), idImmChain, v)

proc chainId*(e: ImmediateExpr): uint32 =
  ## Optional chain ID, used internally by nftables.
  getU32(toRaw(e), idImmChainId)

proc `chainId=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmChainId, v)
</file>

<file path="harness/nftnl/attrs/expr/limit.nim">
# ===========================================================================
# ðŸ§© nftnl "limit" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32

# ---------------------------------------------------------------------------
# Attribute IDs (mirroring libnftnl limit_attr_policy)
# ---------------------------------------------------------------------------
const
  idLimitRate* = uint16(NFTNL_EXPR_LIMIT_RATE)
  idLimitUnit* = uint16(NFTNL_EXPR_LIMIT_UNIT)
  idLimitBurst* = uint16(NFTNL_EXPR_LIMIT_BURST)
  idLimitType* = uint16(NFTNL_EXPR_LIMIT_TYPE)
  idLimitFlags* = uint16(NFTNL_EXPR_LIMIT_FLAGS)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc rate*(e: LimitExpr): uint32 =
  ## Base rate (packets or bytes per unit)
  getU32(toRaw(e), idLimitRate)

proc `rate=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitRate, v)

proc unit*(e: LimitExpr): uint32 =
  ## Unit interval (e.g., per second)
  getU32(toRaw(e), idLimitUnit)

proc `unit=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitUnit, v)

proc burst*(e: LimitExpr): uint32 =
  ## Allowed burst (number of packets/bytes exceeding rate)
  getU32(toRaw(e), idLimitBurst)

proc `burst=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitBurst, v)

proc limitType*(e: LimitExpr): uint32 =
  ## Type (NFT_LIMIT_PKT or NFT_LIMIT_BYTE)
  getU32(toRaw(e), idLimitType)

proc `limitType=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitType, v)

proc flags*(e: LimitExpr): uint32 =
  ## Flags (NFT_LIMIT_F_INV, etc.)
  getU32(toRaw(e), idLimitFlags)

proc `flags=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitFlags, v)
</file>

<file path="harness/nftnl/attrs/expr/meta.nim">
import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32, getStr, setStr

# ---------------------------------------------------------------------------
# nftnl "meta" expression attribute accessors
# ---------------------------------------------------------------------------

const
  idMetaKey* = uint16(NFTNL_EXPR_META_KEY)
  idMetaDreg* = uint16(NFTNL_EXPR_META_DREG)
  idMetaSreg* = uint16(NFTNL_EXPR_META_SREG)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc key*(e: MetaExpr): uint32 =
  ## Metadata key (e.g., NFT_META_MARK, NFT_META_IIFNAME, etc.)
  getU32(toRaw(e), idMetaKey)

proc `key=`*(e: MetaExpr, v: uint32) =
  setU32(toRaw(e), idMetaKey, v)

proc dreg*(e: MetaExpr): uint32 =
  ## Destination register for metadata load.
  getU32(toRaw(e), idMetaDreg)

proc `dreg=`*(e: MetaExpr, v: uint32) =
  setU32(toRaw(e), idMetaDreg, v)

proc sreg*(e: MetaExpr): uint32 =
  ## Source register for metadata store.
  getU32(toRaw(e), idMetaSreg)

proc `sreg=`*(e: MetaExpr, v: uint32) =
  setU32(toRaw(e), idMetaSreg, v)

# ---------------------------------------------------------------------------
# Optional string accessors (interface names, etc.)
# ---------------------------------------------------------------------------

proc str*(e: MetaExpr): string =
  ## Metadata string (used for iifname/oifname, etc.)
  getStr(toRaw(e), idMetaSreg)

proc `str=`*(e: MetaExpr, v: string) =
  setStr(toRaw(e), idMetaSreg, v)
</file>

<file path="harness/nftnl/attrs/expr/payload.nim">
import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32

# ---------------------------------------------------------------------------
# nftnl "payload" expression attribute accessors
# ---------------------------------------------------------------------------

const
  idPayloadDreg* = uint16(NFTNL_EXPR_PAYLOAD_DREG)
  idPayloadBase* = uint16(NFTNL_EXPR_PAYLOAD_BASE)
  idPayloadOffset* = uint16(NFTNL_EXPR_PAYLOAD_OFFSET)
  idPayloadLen* = uint16(NFTNL_EXPR_PAYLOAD_LEN)
  # --- checksum-related fields (libnftnl >= 1.2.6) ---
  idPayloadCsumType* = uint16(NFTNL_EXPR_PAYLOAD_CSUM_TYPE)
  idPayloadCsumOffset* = uint16(NFTNL_EXPR_PAYLOAD_CSUM_OFFSET)
  idPayloadFlags* = uint16(NFTNL_EXPR_PAYLOAD_FLAGS)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc base*(e: PayloadExpr): uint32 =
  ## Payload base (e.g., NFT_PAYLOAD_LL_HEADER, NFT_PAYLOAD_NETWORK_HEADER, etc.)
  getU32(toRaw(e), idPayloadBase)

proc `base=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadBase, v)

proc offset*(e: PayloadExpr): uint32 =
  ## Byte offset within the payload.
  getU32(toRaw(e), idPayloadOffset)

proc `offset=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadOffset, v)

proc len*(e: PayloadExpr): uint32 =
  ## Length of the payload slice in bytes.
  getU32(toRaw(e), idPayloadLen)

proc `len=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadLen, v)

proc dreg*(e: PayloadExpr): uint32 =
  ## Destination register to write payload data into.
  getU32(toRaw(e), idPayloadDreg)

proc `dreg=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadDreg, v)

# ---------------------------------------------------------------------------
# Optional checksum-related fields
# ---------------------------------------------------------------------------

proc csumType*(e: PayloadExpr): uint32 =
  ## Payload checksum type (e.g., NFT_PAYLOAD_CSUM_INET)
  getU32(toRaw(e), idPayloadCsumType)

proc `csumType=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadCsumType, v)

proc csumOffset*(e: PayloadExpr): uint32 =
  ## Payload checksum offset in bytes.
  getU32(toRaw(e), idPayloadCsumOffset)

proc `csumOffset=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadCsumOffset, v)

proc flags*(e: PayloadExpr): uint32 =
  ## Payload flags (e.g., NFT_PAYLOAD_L4CSUM_PSEUDOHDR, etc.)
  getU32(toRaw(e), idPayloadFlags)

proc `flags=`*(e: PayloadExpr, v: uint32) =
  setU32(toRaw(e), idPayloadFlags, v)
</file>

<file path="harness/nftnl/attrs/expr/quota.nim">
# ===========================================================================
# ðŸ§© nftnl "quota" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32

# ---------------------------------------------------------------------------
# Attribute IDs (mirroring libnftnl quota_attr_policy)
# ---------------------------------------------------------------------------
const
  idQuotaBytes* = uint16(NFTNL_EXPR_QUOTA_BYTES)
  idQuotaFlags* = uint16(NFTNL_EXPR_QUOTA_FLAGS)
  idQuotaConsumed* = uint16(NFTNL_EXPR_QUOTA_CONSUMED)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc bytes*(e: QuotaExpr): uint64 =
  ## Total quota bytes allowed.
  getU64(toRaw(e), idQuotaBytes)

proc `bytes=`*(e: QuotaExpr, v: uint64) =
  setU64(toRaw(e), idQuotaBytes, v)

proc flags*(e: QuotaExpr): uint32 =
  ## Flags for quota behavior (e.g., NFT_QUOTA_F_INV, NFT_QUOTA_F_OVER).
  getU32(toRaw(e), idQuotaFlags)

proc `flags=`*(e: QuotaExpr, v: uint32) =
  setU32(toRaw(e), idQuotaFlags, v)

proc consumed*(e: QuotaExpr): uint64 =
  ## How many bytes have been consumed so far.
  getU64(toRaw(e), idQuotaConsumed)

proc `consumed=`*(e: QuotaExpr, v: uint64) =
  setU64(toRaw(e), idQuotaConsumed, v)
</file>

<file path="harness/nftnl/attrs/chain.nim">
import macros
import ../autogenerated/generated_nftnl
import ../raii/basics
import ../helpers

# --- expected type mapping ----------------------------------------------------
template expectedType*(attr: static enum_nftnl_chain_attr): untyped =
  when attr in {
    NFTNL_CHAIN_NAME, NFTNL_CHAIN_TABLE, NFTNL_CHAIN_TYPE, NFTNL_CHAIN_DEV,
    NFTNL_CHAIN_USERDATA,
  }:
    string
  elif attr in
      {NFTNL_CHAIN_FAMILY, NFTNL_CHAIN_HOOKNUM, NFTNL_CHAIN_PRIO, NFTNL_CHAIN_POLICY}:
    uint32
  elif attr in {NFTNL_CHAIN_HANDLE}:
    uint64
  else:
    {.error: "Unsupported chain attribute: " & $attr.}

# --- raw unified coercion -----------------------------------------------------
proc rawGetAttr*[T](c: ptr struct_nftnl_chain, attr: uint16): T =
  when T is string:
    $cast[cstring](nftnl_chain_get_str(c, attr))
  elif T is uint32:
    nftnl_chain_get_u32(c, attr)
  elif T is uint64:
    nftnl_chain_get_u64(c, attr)
  else:
    {.error: "Unsupported type".}

# Set an attribute on a chain, dispatching by value type.
proc rawSetAttr*(c: ptr struct_nftnl_chain, attr: uint16, v: auto) =
  when typeof(v) is string:
    discard nftnl_chain_set_str(c, attr, cast[ptr uint8](v.cstring))
  elif typeof(v) is uint32:
    nftnl_chain_set_u32(c, attr, v)
  elif typeof(v) is uint64:
    nftnl_chain_set_u64(c, attr, v)
  elif typeof(v) is SomeInteger or typeof(v) is enum:
    let val = v.asIntLike
    when fitsU32(val):
      nftnl_chain_set_u32(c, attr, val.toCWidth)
    else:
      nftnl_chain_set_u64(c, attr, val.toCWidth)
  else:
    {.error: "Unsupported type".}

# --- macro sugar --------------------------------------------------------------
macro attrOp*(c: typed, attr: enum_nftnl_chain_attr, args: varargs[untyped]): untyped =
  result =
    if args.len == 0:
      quote:
        rawGetAttr[expectedType(`attr`)](`c`.raw, `attr`.uint16)
    elif args.len == 1:
      quote:
        rawSetAttr(`c`.raw, `attr`.uint16, `args [ 0 ]`)
    else:
      error "attrOp takes 0 or 1 arguments"

# --- convenience wrappers -----------------------------------------------------
template setAttr*(c: Chain, attr: enum_nftnl_chain_attr, val: untyped): untyped =
  attrOp(c, attr, val)

template getAttr*(c: Chain, attr: enum_nftnl_chain_attr): untyped =
  attrOp(c, attr)

template defChainProp(attr: static enum_nftnl_chain_attr, propName: untyped) =
  proc propName*(c: Chain): expectedType(attr) =
    c.getAttr(attr)

  proc `propName=`*(c: Chain, v: expectedType(attr)) =
    c.setAttr(attr, v)

# String properties
defChainProp(NFTNL_CHAIN_NAME, name)
defChainProp(NFTNL_CHAIN_TABLE, table)
defChainProp(NFTNL_CHAIN_TYPE, typeName)
defChainProp(NFTNL_CHAIN_DEV, dev)
defChainProp(NFTNL_CHAIN_USERDATA, userdata)

# uint32 properties
defChainProp(NFTNL_CHAIN_FAMILY, family)
defChainProp(NFTNL_CHAIN_HOOKNUM, hooknum)
defChainProp(NFTNL_CHAIN_PRIO, prio)
defChainProp(NFTNL_CHAIN_POLICY, policy)

# uint64 properties
defChainProp(NFTNL_CHAIN_HANDLE, handle)
</file>

<file path="harness/nftnl/attrs/rule.nim">
import macros
import ../autogenerated/generated_nftnl
import ../raii/basics
import ../helpers

# --- expected type mapping ----------------------------------------------------
template expectedType*(attr: static enum_nftnl_rule_attr): untyped =
  when attr in {NFTNL_RULE_TABLE, NFTNL_RULE_CHAIN, NFTNL_RULE_USERDATA}:
    string
  elif attr in {NFTNL_RULE_FAMILY, NFTNL_RULE_COMPAT_PROTO, NFTNL_RULE_COMPAT_FLAGS}:
    uint32
  elif attr in {NFTNL_RULE_HANDLE}:
    uint64
  else:
    {.error: "Unsupported rule attribute: " & $attr.}

# --- raw unified coercion -----------------------------------------------------
proc rawGetAttr*[T](r: ptr struct_nftnl_rule, attr: uint16): T =
  when T is string:
    $cast[cstring](nftnl_rule_get_str(r, attr))
  elif T is uint32:
    nftnl_rule_get_u32(r, attr)
  elif T is uint64:
    nftnl_rule_get_u64(r, attr)
  else:
    {.error: "Unsupported type".}

proc rawSetAttr*(r: ptr struct_nftnl_rule, attr: uint16, v: auto) =
  when typeof(v) is string:
    discard nftnl_rule_set_str(r, attr, cast[ptr uint8](v.cstring))
  elif typeof(v) is uint32:
    nftnl_rule_set_u32(r, attr, v)
  elif typeof(v) is uint64:
    nftnl_rule_set_u64(r, attr, v)
  elif typeof(v) is SomeInteger or typeof(v) is enum:
    let val = v.asIntLike
    when fitsU32(val):
      nftnl_rule_set_u32(r, attr, val.toCWidth)
    else:
      nftnl_rule_set_u64(r, attr, val.toCWidth)
  else:
    {.error: "Unsupported type".}

# --- macro sugar --------------------------------------------------------------
macro attrOp*(r: typed, attr: enum_nftnl_rule_attr, args: varargs[untyped]): untyped =
  result =
    if args.len == 0:
      quote:
        rawGetAttr[expectedType(`attr`)](`r`.raw, `attr`.uint16)
    elif args.len == 1:
      quote:
        rawSetAttr(`r`.raw, `attr`.uint16, `args [ 0 ]`)
    else:
      error "attrOp takes 0 or 1 arguments"

# --- convenience wrappers -----------------------------------------------------
template setAttr*(r: Rule, attr: enum_nftnl_rule_attr, val: untyped): untyped =
  attrOp(r, attr, val)

template getAttr*(r: Rule, attr: enum_nftnl_rule_attr): untyped =
  attrOp(r, attr)

template defRuleProp(attr: static enum_nftnl_rule_attr, propName: untyped) =
  proc propName*(r: Rule): expectedType(attr) =
    r.getAttr(attr)

  proc `propName=`*(r: Rule, v: expectedType(attr)) =
    r.setAttr(attr, v)

# --- String properties ---
defRuleProp(NFTNL_RULE_TABLE, table)
defRuleProp(NFTNL_RULE_CHAIN, chain)
defRuleProp(NFTNL_RULE_USERDATA, userdata)

# --- uint32 properties ---
defRuleProp(NFTNL_RULE_FAMILY, family)
defRuleProp(NFTNL_RULE_COMPAT_PROTO, compatProto)
defRuleProp(NFTNL_RULE_COMPAT_FLAGS, compatFlags)

# --- uint64 properties ---
defRuleProp(NFTNL_RULE_HANDLE, handle)
</file>

<file path="harness/nftnl/attrs/table.nim">
import macros
import ../autogenerated/generated_nftnl
import ../raii/basics
import ../helpers

# --- expected type mapping ----------------------------------------------------
template expectedType*(attr: static enum_nftnl_table_attr): untyped =
  when attr in {NFTNL_TABLE_NAME, NFTNL_TABLE_USERDATA, NFTNL_TABLE_OWNER}:
    string
  elif attr in {NFTNL_TABLE_FAMILY, NFTNL_TABLE_FLAGS, NFTNL_TABLE_USE}:
    uint32
  elif attr in {NFTNL_TABLE_HANDLE}:
    uint64
  else:
    {.error: "Unsupported table attribute: " & $attr.}

# --- raw unified coercion -----------------------------------------------------
proc rawGetAttr*[T](t: ptr struct_nftnl_table, attr: uint16): T =
  when T is string:
    $cast[cstring](nftnl_table_get_str(t, attr))
  elif T is uint32:
    nftnl_table_get_u32(t, attr)
  elif T is uint64:
    nftnl_table_get_u64(t, attr)
  else:
    {.error: "Unsupported type".}

proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: auto) =
  when typeof(v) is string:
    discard nftnl_table_set_str(t, attr, cast[ptr uint8](v.cstring))
  elif typeof(v) is uint32:
    nftnl_table_set_u32(t, attr, v)
  elif typeof(v) is uint64:
    nftnl_table_set_u64(t, attr, v)
  elif typeof(v) is SomeInteger:
    when fitsU32(v):
      nftnl_table_set_u32(t, attr, v.toCWidth)
    else:
      nftnl_table_set_u64(t, attr, v.toCWidth)
  else:
    {.error: "Unsupported type".}

# --- the one-liner macro ------------------------------------------------------
macro attrOp*(t: typed, attr: enum_nftnl_table_attr, args: varargs[untyped]): untyped =
  result =
    if args.len == 0:
      quote:
        rawGetAttr[expectedType(`attr`)](`t`.raw, `attr`.uint16)
    elif args.len == 1:
      quote:
        rawSetAttr(`t`.raw, `attr`.uint16, `args [ 0 ]`)
    else:
      error "attrOp takes 0 or 1 arguments"

# --- convenience --------------------------------------------------------------
template setAttr*(t: Table, attr: enum_nftnl_table_attr, val: untyped): untyped =
  attrOp(t, attr, val)

template getAttr*(t: Table, attr: enum_nftnl_table_attr): untyped =
  attrOp(t, attr)

template defTableProp(attr: static enum_nftnl_table_attr, propName: untyped) =
  proc propName*(t: Table): expectedType(attr) =
    t.getAttr(attr)

  proc `propName=`*(t: Table, v: expectedType(attr)) =
    t.setAttr(attr, v)

# String properties
defTableProp(NFTNL_TABLE_NAME, name)
defTableProp(NFTNL_TABLE_USERDATA, userdata)
defTableProp(NFTNL_TABLE_OWNER, owner)

# uint32 properties
defTableProp(NFTNL_TABLE_FAMILY, family)
defTableProp(NFTNL_TABLE_FLAGS, flags)

# uint64 properties
defTableProp(NFTNL_TABLE_HANDLE, handle)
</file>

<file path="harness/nftnl/raii/basics.nim">
{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

template makeWrapper(typeName, structName, allocFn, freeFn: untyped) =
  type `typeName`* = object
    raw*: ptr `structName`

  proc create*(_: type `typeName`): `typeName` =
    `typeName`(raw: allocFn())

  proc `=destroy`*(x: var `typeName`) =
    if x.raw != nil:
      freeFn(x.raw)
      x.raw = nil

  proc `=wasMoved`*(x: var `typeName`) =
    x.raw = nil

  proc `=copy`*(dst: var `typeName`, src: `typeName`) {.error.}

  proc `=sink`*(dst: var `typeName`, src: `typeName`) =
    if dst.raw == src.raw:
      return
    `=destroy`(dst)
    dst.raw = src.raw

  proc raw*(x: `typeName`): ptr `structName` {.inline.} =
    x.raw

# --- concrete wrappers -----------------------------------------------------
makeWrapper(Table, struct_nftnl_table, nftnl_table_alloc, nftnl_table_free)
makeWrapper(Chain, struct_nftnl_chain, nftnl_chain_alloc, nftnl_chain_free)
makeWrapper(Rule, struct_nftnl_rule, nftnl_rule_alloc, nftnl_rule_free)
makeWrapper(Set, struct_nftnl_set, nftnl_set_alloc, nftnl_set_free)
makeWrapper(
  TableList, struct_nftnl_table_list, nftnl_table_list_alloc, nftnl_table_list_free
)
makeWrapper(
  ChainList, struct_nftnl_chain_list, nftnl_chain_list_alloc, nftnl_chain_list_free
)
makeWrapper(
  RuleList, struct_nftnl_rule_list, nftnl_rule_list_alloc, nftnl_rule_list_free
)
makeWrapper(SetList, struct_nftnl_set_list, nftnl_set_list_alloc, nftnl_set_list_free)
makeWrapper(SetElem, struct_nftnl_set_elem, nftnl_set_elem_alloc, nftnl_set_elem_free)
</file>

<file path="harness/nftnl/raii/expresions.nim">
{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

# ===========================================================================
# ðŸ§© Generic Expression RAII wrapper
# ===========================================================================

type Expression* = object
  raw*: ptr struct_nftnl_expr

# ---------------------------------------------------------------------------
# Lifecycle management
# ---------------------------------------------------------------------------

proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

# ===========================================================================
# ðŸ§© Strongly-typed variants (only the ones weâ€™ll support)
# ===========================================================================

type
  PayloadExpr* = distinct Expression
  CmpExpr* = distinct Expression
  MetaExpr* = distinct Expression
  BitwiseExpr* = distinct Expression
  ImmediateExpr* = distinct Expression
  CounterExpr* = distinct Expression
  CtExpr* = distinct Expression
  LimitExpr* = distinct Expression
  QuotaExpr* = distinct Expression

# ---------------------------------------------------------------------------
# Constructors enforce correct nftnl kind
# ---------------------------------------------------------------------------

proc create*(_: type PayloadExpr): PayloadExpr =
  PayloadExpr(Expression.create("payload"))

proc create*(_: type CmpExpr): CmpExpr =
  CmpExpr(Expression.create("cmp"))

proc create*(_: type MetaExpr): MetaExpr =
  MetaExpr(Expression.create("meta"))

proc create*(_: type BitwiseExpr): BitwiseExpr =
  BitwiseExpr(Expression.create("bitwise"))

proc create*(_: type ImmediateExpr): ImmediateExpr =
  ImmediateExpr(Expression.create("immediate"))

proc create*(_: type CounterExpr): CounterExpr =
  CounterExpr(Expression.create("counter"))

proc create*(_: type CtExpr): CtExpr =
  CtExpr(Expression.create("ct"))

proc create*(_: type LimitExpr): LimitExpr =
  LimitExpr(Expression.create("limit"))

proc create*(_: type QuotaExpr): QuotaExpr =
  QuotaExpr(Expression.create("quota"))

# ===========================================================================
# ðŸª„ Implicit converters
# ===========================================================================

converter toExpression*(e: sink PayloadExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CmpExpr): Expression =
  Expression(e)

converter toExpression*(e: sink MetaExpr): Expression =
  Expression(e)

converter toExpression*(e: sink BitwiseExpr): Expression =
  Expression(e)

converter toExpression*(e: sink ImmediateExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CounterExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CtExpr): Expression =
  Expression(e)

converter toExpression*(e: sink LimitExpr): Expression =
  Expression(e)

converter toExpression*(e: sink QuotaExpr): Expression =
  Expression(e)

# ===========================================================================
# ðŸ”§ Generic raw() / toRaw() accessors
# ===========================================================================

template raw*(e: typed): ptr struct_nftnl_expr =
  when e is Expression:
    e.raw
  else:
    Expression(e).raw

template toRaw*(e: typed): ptr struct_nftnl_expr =
  when e is Expression:
    e.raw
  else:
    Expression(e).raw
</file>

<file path="harness/nftnl/raii/generator.nim">
{.passC: staticExec("pkg-config --cflags libnftnl").}
{.passL: staticExec("pkg-config --libs   libnftnl").}

from os import parentDir, `/`
import futhark, os

when defined(useFuthark):
  const
    glibcInclude = staticExec("nix eval --raw nixpkgs#glibc.dev.outPath") & "/include"
    nftnlInclude = staticExec("pkg-config --variable=includedir libnftnl")
    outDir = currentSourcePath.parentDir / "autogenerated"
    outFile = outDir / "generated_nftnl.nim"

  static:
    if not dirExists(outDir):
      createDir(outDir)

  importc:
    # --- Output target ---
    outputPath outFile.string

    # --- Header include roots ---
    path glibcInclude
    path nftnlInclude

    # --- Core libnftnl components ---
    "libnftnl/table.h"
    "libnftnl/chain.h"
    "libnftnl/rule.h"
    "libnftnl/set.h"
    "libnftnl/expr.h"
    "libnftnl/object.h"
</file>

<file path="harness/nftnl/raii/iterators.nim">
# src/nftnl/iterators.nim
import ../autogenerated/generated_nftnl
import ./basics

#
# View types (non-owning)
# These just wrap raw pointers returned by libnftnl lists/iterators.
# They DO NOT free memory on destruction.
#
type
  TableView* = object
    raw*: ptr struct_nftnl_table

  ChainView* = object
    raw*: ptr struct_nftnl_chain

  RuleView* = object
    raw*: ptr struct_nftnl_rule

  SetView* = object
    raw*: ptr struct_nftnl_set

  SetElemView* = object
    raw*: ptr struct_nftnl_set_elem

#
# Generic iterator template
#
template defineIterator(
    iterName, viewType, listWrapType, itemType, createFn, nextFn, destroyFn: untyped
) =
  iterator `iterName`*(list: listWrapType): viewType =
    var it = createFn(list.raw)
    defer:
      destroyFn(it)

    var next: ptr itemType
    while true:
      next = nextFn(it)
      if next.isNil:
        break
      yield viewType(raw: next)

#
# Iterators
#

# For tables
defineIterator(
  tableIter, TableView, TableList, struct_nftnl_table, nftnl_table_list_iter_create,
  nftnl_table_list_iter_next, nftnl_table_list_iter_destroy,
)

# For chains
defineIterator(
  chainIter, ChainView, ChainList, struct_nftnl_chain, nftnl_chain_list_iter_create,
  nftnl_chain_list_iter_next, nftnl_chain_list_iter_destroy,
)

# For rules
defineIterator(
  ruleIter, RuleView, RuleList, struct_nftnl_rule, nftnl_rule_list_iter_create,
  nftnl_rule_list_iter_next, nftnl_rule_list_iter_destroy,
)

# For sets
defineIterator(
  setIter, SetView, SetList, struct_nftnl_set, nftnl_set_list_iter_create,
  nftnl_set_list_iter_next, nftnl_set_list_iter_destroy,
)

# For set elements (special API: cur/next)
iterator setElemIter*(s: SetView): SetElemView =
  var it = nftnl_set_elems_iter_create(s.raw)
  defer:
    nftnl_set_elems_iter_destroy(it)

  while true:
    let cur = nftnl_set_elems_iter_cur(it)
    if cur.isNil:
      break
    yield SetElemView(raw: cur)
    discard nftnl_set_elems_iter_next(it)
</file>

<file path="harness/nftnl/helpers.nim">
# True if the integer fits within 32 bits (decided at compile time).
template fitsU32*(x: typed): bool =
  sizeof(x) <= 4

# Convert an integer-like value (int, uint, etc.) to its C-compatible width.
template toCWidth*(x: typed): untyped =
  when fitsU32(x): x.uint32 else: x.uint64

# Normalize an enum or integer value to a plain integer for FFI use.
template asIntLike*(x: typed): untyped =
  when typeof(x) is enum:
    ord(x)
  else:
    x
</file>

<file path="harness/export_fuzz.nim">
import std/[strutils, streams, os, posix, times]
import ./proto_raw as pb
import ./harness
import ./mappings
import protobuf_serialization

const
  LogPath = "/tmp/nim_fuzz.log"
  FlushEvery = 20
  FlushSeconds = 2.0

var
  logBuffer: seq[string]
  lastFlush = epochTime()

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------

proc flushLogs() =
  if logBuffer.len == 0:
    return
  try:
    var f = open(LogPath, fmAppend)
    for msg in logBuffer:
      f.writeLine(msg)
    f.close()
    logBuffer.setLen(0)
    lastFlush = epochTime()
  except CatchableError:
    discard

proc fileEcho(msg: string) =
  logBuffer.add(msg)
  let now = epochTime()
  if logBuffer.len >= FlushEvery or (now - lastFlush) > FlushSeconds:
    flushLogs()

# ---------------------------------------------------------------------------
# Protobuf decoding
# ---------------------------------------------------------------------------

proc decodeTop*(data: openArray[byte]): pb.Top =
  try:
    result = Protobuf.decode(data, pb.Top)
  except CatchableError as e:
    fileEcho "[decodeTop] parse error: " & e.msg
    result = pb.Top()

# ---------------------------------------------------------------------------
# Sanitization helpers
# ---------------------------------------------------------------------------

proc sanitizeExpr(e: var pb.Expr) =
  ## Per-expression light normalization (flattened schema)
  # Cap blobs to prevent large allocations
  if e.data.len > 1024:
    e.data.setLen(256)
  if e.mask.len > 1024:
    e.mask.setLen(256)
  if e.xor.len > 1024:
    e.xor.setLen(256)
  # Cap strings
  if e.str.len > 256:
    e.str = e.str.substr(0, 256)
  if e.chain.len > 128:
    e.chain = e.chain.substr(0, 128)
  # Cap obviously large numbers
  if e.offset > 10_000_000'u32:
    e.offset = e.offset mod 65536'u32
  if e.len > 1_000_000'u32:
    e.len = 1024'u32
  # Normalize small fields
  e.base = e.base and 0xff'u32
  e.dreg = e.dreg and 0xff'u32
  e.sreg = e.sreg and 0xff'u32
  e.op = e.op and 0xffff'u32
  e.key = e.key and 0xffff'u32

  let kind = int(e.`type`)
  if kind < 1 or kind > 9:
    e.`type` = 0'u32
    e.data = @[]
    e.mask = @[]
    e.xor = @[]
    e.str = ""
    return

  case kind
  of 1: # payload
    if e.base > 0xff'u32:
      e.base = e.base and 0xff'u32
    if e.dreg > 0xff'u32:
      e.dreg = e.dreg and 0xff'u32
  of 2: # cmp
    if e.data.len == 0:
      e.data = @[0x12'u8, 0x34'u8]
    elif e.data.len > 64:
      e.data.setLen(16)
    e.op = e.op and 0x7'u32
    e.sreg = e.sreg and 0xff'u32
  of 3: # meta
    if e.str.len > 64:
      e.str = e.str.substr(0, 64)
    e.key = e.key and 0xffff'u32
  of 4: # bitwise
    if e.len > 64'u32:
      e.len = 64'u32
    if e.mask.len == 0:
      e.mask = @[0xff'u8]
    if e.mask.len > 64:
      e.mask.setLen(16)
    if e.xor.len > 64:
      e.xor.setLen(16)
  of 5: # immediate
    if e.data.len > 128:
      e.data.setLen(32)
    if e.chain.len > 64:
      e.chain = e.chain.substr(0, 64)
  of 6:
    discard
  # counter
  of 7: # ct
    e.op = e.op and 0x1'u32
    e.key = e.key and 0xffff'u32
    e.dreg = e.dreg and 0xff'u32
  of 8: # limit
    if e.base > 1_000_000'u32:
      e.base = e.base mod 100000'u32
    if e.len > 3600'u32:
      e.len = e.len mod 3600'u32
    e.key = e.key and 0xff'u32
  of 9: # quota
    if e.base > 10_000_000'u32:
      e.base = e.base mod 1_000_000'u32
    e.op = e.op and 0xff'u32
  else:
    discard

proc sanitizeRule(
    r: var pb.Rule, parentTable, parentChain: string, parentFamily: uint32
) =
  if r.table.len == 0:
    r.table = parentTable
  if r.chain.len == 0:
    r.chain = parentChain
  if r.family == 0'u32:
    r.family = parentFamily
  for ei in 0 ..< r.exprs.len:
    sanitizeExpr(r.exprs[ei])

proc sanitizeChain(c: var pb.Chain, parentTable: string, parentFamily: uint32) =
  if c.table.len == 0:
    c.table = parentTable
  if c.name.len == 0:
    c.name = "input"
  if c.`type`.len == 0:
    c.`type` = "filter"
  if c.hook > 255'u32:
    c.hook = c.hook mod 256'u32
  if c.prio > 1000000 or c.prio < -1000000:
    c.prio = 0
  if c.policy != 0'u32 and c.policy != 1'u32:
    c.policy = 1'u32
  for ri in 0 ..< c.rules.len:
    sanitizeRule(c.rules[ri], c.table, c.name, parentFamily)

proc sanitizeTable(t: var pb.Table) =
  if t.name.len == 0:
    t.name = "filter"
  if t.family == 0'u32:
    t.family = 2'u32
  for ci in 0 ..< t.chains.len:
    sanitizeChain(t.chains[ci], t.name, t.family)

proc sanitizeTop*(top: var pb.Top) =
  if top.tables.len == 0:
    return
  for ti in 0 ..< top.tables.len:
    sanitizeTable(top.tables[ti])

# ---------------------------------------------------------------------------
# Main fuzz entrypoint
# ---------------------------------------------------------------------------

proc run_from_pb*(
    data: ptr uint8, len: csize_t
): cint {.exportc: "run_from_pb", cdecl, dynlib.} =
  try:
    fileEcho ">>> run_from_pb invoked (" & $len & " bytes)"
    flushLogs()  # ensure the first line lands even if we crash next

    # Guard nil/zero-length
    if data.isNil or len == 0:
      fileEcho "[info] Empty input; skipping"
      return 0

    var buf = newSeq[byte](int len)
    # safe: len > 0 so buf has at least one element
    copyMem(addr buf[0], data, len)

    var top = decodeTop(buf)
    sanitizeTop(top)
    fileEcho "top.tables.len = " & $top.tables.len
    if top.tables.len == 0:
      fileEcho "[info] Empty or invalid Top"
      return 0

    for t in top.tables:
      fileEcho "--- Table ---"
      fileEcho "name: " & t.name
      fileEcho "family: " & $t.family

    discard buildTop(top)
    flushLogs()
    return 0
  except CatchableError as e:
    fileEcho "[Nim fuzz harness error] " & e.msg
    flushLogs()
    return -1
</file>

<file path="harness/harness.nim">
{.warning[UnusedImport]: off.}

{.passC: staticExec("pkg-config --cflags libnftnl").}
{.passL: staticExec("pkg-config --libs   libnftnl").}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Low-level generated bindings
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import nftnl/autogenerated/generated_nftnl as gen_nftnl
import linux/autogenerated/generated_linux as gen_linux
export gen_nftnl, gen_linux

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# RAII & attribute layers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import nftnl/raii/[basics, iterators, expresions]
import nftnl/attrs/[table, chain, rule]
import nftnl/attrs/expr/[cmp, payload, meta, bitwise, immediate, counter]
import messageBuilder

export
  basics, iterators, expresions, table, chain, rule, cmp, payload, meta, bitwise,
  immediate, counter, messageBuilder

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# High-level mapping helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import ./mappings
export mappings
</file>

<file path="harness/mappings.nim">
import ./mappings/build_top
export build_top
</file>

<file path="harness/messageBuilder.nim">
import ./mnl/autogenerated/generated_mnl as mnl
import ./nftnl/autogenerated/generated_nftnl as nftnl
import ./nftnl/raii/basics
import ./nftnl/raii/expresions
import ./linux/autogenerated/generated_linux as linux

# Alias to avoid ambiguous struct names
type NlMsgHdr* = nftnl.struct_nlmsghdr

const MNL_SOCKET_BUFFER_SIZE* = 8 * 1024

# ---------------------------------------------------------------------
# ðŸ§± Base Netlink message creation
# ---------------------------------------------------------------------
proc newNlMsg*(msgType: cint, family: cint, flags: cint, seq: uint32): ptr NlMsgHdr =
  ## Allocate a userland buffer and initialize a netlink message header
  let buf = cast[ptr uint8](alloc0(MNL_SOCKET_BUFFER_SIZE))
  result =
    nftnl.nftnl_nlmsg_build_hdr(buf, msgType.uint16, family.uint16, flags.uint16, seq)
  if result.isNil:
    raise newException(OSError, "Failed to build nlmsghdr")

# ---------------------------------------------------------------------
# ðŸ§± Message builders for nftnl objects
# ---------------------------------------------------------------------
proc buildTableMsg*(nlh: ptr NlMsgHdr, t: Table) =
  nftnl.nftnl_table_nlmsg_build_payload(nlh, t.raw)

proc buildChainMsg*(nlh: ptr NlMsgHdr, c: Chain) =
  nftnl.nftnl_chain_nlmsg_build_payload(nlh, c.raw)

proc buildRuleMsg*(nlh: ptr NlMsgHdr, r: Rule) =
  nftnl.nftnl_rule_nlmsg_build_payload(nlh, r.raw)

# ---------------------------------------------------------------------
# ðŸ§± Expression management
# ---------------------------------------------------------------------
proc addExpr*(r: Rule, e: sink Expression) =
  ## Add a generic expression to a rule. Transfers ownership to libnftnl.
  if r.raw.isNil or e.raw.isNil:
    return
  nftnl_rule_add_expr(r.raw, e.raw)
  e.raw = nil # ownership moved to libnftnl

proc addExpr*(r: Rule, e: sink CmpExpr) =
  addExpr(r, Expression(e))

proc addExpr*(r: Rule, e: sink PayloadExpr) =
  addExpr(r, Expression(e))

proc addExpr*(r: Rule, e: sink MetaExpr) =
  addExpr(r, Expression(e))

proc addExpr*(r: Rule, e: sink BitwiseExpr) =
  addExpr(r, Expression(e))

# ---------------------------------------------------------------------
# ðŸ§± Convenience constructor for rule messages
# ---------------------------------------------------------------------
template newRuleNlMsg*(seq: uint32): ptr NlMsgHdr =
  ## Allocates and initializes a Netlink message for NFT_MSG_NEWRULE
  ## using standard flags (CREATE | EXCL | ACK).
  newNlMsg(
    NFT_MSG_NEWRULE.cint,
    linux.AF_INET.cint, # disambiguated here
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seq,
  )
</file>

<file path="harness/proto_raw.nim">
# harness/proto_raw.nim
import protobuf_serialization
import protobuf_serialization/proto_parser

# Generate Nim types and (de)serializers at compile time
import_proto3 "../schema/elaborate.proto"
</file>

<file path="mutator/lpm_consumer.cpp">
#include "elaborate.pb.h"
#include "src/libfuzzer/libfuzzer_macro.h"
#include <string>
#include <cstdint>
#include <cstdlib>

// Nim harness entrypoint
extern "C" int run_from_pb(const uint8_t *data, size_t len);

// ---- LLVM profile runtime (flush / config) ----
extern "C" {
  void __llvm_profile_register_write_file_atexit(void);
  int  __llvm_profile_write_file(void);
  void __llvm_profile_set_filename(const char *);
  void __llvm_profile_enable_continuous_mode(void); // optional
}

// (optional) sanitizer coverage symbols
extern "C" {
__attribute__((weak)) size_t __sanitizer_get_total_unique_coverage(void);
__attribute__((weak)) size_t __sanitizer_get_total_coverage(void);
__attribute__((weak)) size_t __sanitizer_get_number_of_counters(void);
}

// libFuzzer init hook
extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv) {
  (void)argc; (void)argv;

  // Ensure the runtime knows where to write (use env if set)
  if (const char* p = std::getenv("LLVM_PROFILE_FILE")) {
    __llvm_profile_set_filename(p);
  }

  // Safer on abnormal exits; cheap to enable
  __llvm_profile_enable_continuous_mode();

  // Make sure we flush on normal exit
  __llvm_profile_register_write_file_atexit();
  return 0;
}

// protobuf-mutator postprocessor (unchanged)
template <class Proto>
using PostProcessor = protobuf_mutator::libfuzzer::PostProcessorRegistration<Proto>;

static PostProcessor<nftnl::Top> ensure_seed = {
  [](nftnl::Top *m, unsigned int) {
    if (m->tables_size() == 0) {
      auto *t = m->add_tables();
      t->set_family(2);
      t->set_name("seed");
    }
  }
};

// Fuzz target (unchanged)
DEFINE_PROTO_FUZZER(const nftnl::Top &in) {
  std::string serialized;
  if (!in.SerializeToString(&serialized) || serialized.empty())
    return;

  run_from_pb(reinterpret_cast<const uint8_t *>(serialized.data()),
              serialized.size());
}
</file>

<file path="schema/elaborate.proto">
syntax = "proto3";
package nftnl;

// ---------------------------------------------------------------------------
// Expression kinds (mirroring nftnl expr_ops_* types)
// ---------------------------------------------------------------------------
enum ExprType {
  EXPR_UNSPEC = 0;
  EXPR_PAYLOAD = 1;
  EXPR_CMP = 2;
  EXPR_META = 3;
  EXPR_BITWISE = 4;
  EXPR_IMMEDIATE = 5;
  EXPR_COUNTER = 6;
  EXPR_CT = 7;
  EXPR_LIMIT = 8;
  EXPR_QUOTA = 9;
  EXPR_NAT = 10;
  EXPR_REDIR = 11;
  EXPR_REJECT = 12;
}

// ---------------------------------------------------------------------------
// Flattened expression message (covers all known nftnl expr types)
// ---------------------------------------------------------------------------
message Expr {
  uint32 id = 1;   // Optional debugging or stable ID
  uint32 type = 2; // Expression kind (raw numeric; corresponds to ExprType)

  // Generic numeric fields (registers, ops, etc.)
  uint32 sreg = 3;
  uint32 dreg = 4;
  uint32 op = 5;
  uint32 base = 6;
  uint32 key = 7;
  uint32 offset = 8;
  uint32 len = 9;

  // Binary blobs (used by cmp, bitwise, etc.)
  bytes data = 10;
  bytes mask = 11;
  bytes xor = 12;

  // Optional string (metadata, interface names, etc.)
  string str = 13;

  // Attribute mask (bitwise indicator of which fields are active)
  // Extended bits (beyond 10):
  //   0: sreg
  //   1: dreg
  //   2: op
  //   3: base
  //   4: key
  //   5: offset
  //   6: len
  //   7: data
  //   8: mask
  //   9: xor
  //  10: str
  //  11: csum_type
  //  12: csum_offset
  //  13: csum_flags
  //  14: verdict
  //  15: chain
  //  16: chain_id
  uint32 attr_mask = 14;

  // Payload-specific checksum fields
  uint32 csum_type = 15;
  uint32 csum_offset = 16;
  uint32 csum_flags = 17;

  // Immediate / verdict-like expressions
  uint32 verdict = 18;  // NF_ACCEPT, NF_DROP, NF_JUMP, etc.
  string chain = 19;    // Optional jump chain name
  uint32 chain_id = 20; // Optional chain ID
}

// ---------------------------------------------------------------------------
// Rule â†’ Chain â†’ Table â†’ Top-level hierarchy
// ---------------------------------------------------------------------------
message Rule {
  uint32 family = 1;
  string table = 2;
  string chain = 3;
  repeated Expr exprs = 4;
}

message Chain {
  uint32 family = 1;
  string table = 2;
  string name = 3;
  string type = 4;
  uint32 hook = 5;
  sint32 prio = 6;
  uint32 policy = 7;
  repeated Rule rules = 8;
}

message Table {
  uint32 family = 1;
  string name = 2;
  repeated Chain chains = 3;
}

message Top { repeated Table tables = 1; }
</file>

<file path="tests/bench/bench_table.nim">
import times
import harness

proc oneExec() =
  var t = Table.create()
  t.name = "x"
  t.family = 2

  var buf: array[4096, uint8]
  discard
    nftnl_table_snprintf(addr buf[0], csize_t(buf.len), t.raw, uint32(0), uint32(0))

when isMainModule:
  let n = 1_000_000
  let t0 = cpuTime()
  for _ in 0 ..< n:
    oneExec()
  let t1 = cpuTime()
  echo "exec/s â‰ˆ ", (n.float / (t1 - t0)).int
</file>

<file path="tests/config.nims">
switch("path", "$projectDir/../harness")
</file>

<file path="tests/core_chain.nim">
discard """
action: "run"
"""

import unittest2 as unittest
import harness

suite "nftnl chain iterators (stubbed)":
  test "empty chain list iterates safely":
    var list = ChainList.create()
    var count = 0
    for chain in chainIter(list):
      discard chain
      inc count
    check count == 0

suite "nftnl chain props typing (runtime)":
  test "string props roundtrip":
    var c = Chain.create()
    c.name = "roundtrip"
    check c.name == "roundtrip"

  test "uint32 props roundtrip":
    var c = Chain.create()
    c.family = AF_INET
    check c.family == AF_INET

  test "uint64 props roundtrip":
    var c = Chain.create()
    c.handle = 12345'u64
    check c.handle == 12345'u64

suite "nftnl chain props sugar":
  test "chain.name roundtrip":
    var c = Chain.create()
    c.name = "viaProps"
    check c.name == "viaProps"

  test "chain.table roundtrip":
    var c = Chain.create()
    c.table = "tbl"
    check c.table == "tbl"

  test "chain.family roundtrip":
    var c = Chain.create()
    c.family = AF_INET
    check c.family == AF_INET

  test "chain.hooknum roundtrip":
    var c = Chain.create()
    c.hooknum = 1'u32
    check c.hooknum == 1'u32

  test "chain.prio roundtrip":
    var c = Chain.create()
    c.prio = 5'u32
    check c.prio == 5'u32

  test "chain.policy roundtrip":
    var c = Chain.create()
    c.policy = 0'u32
    check c.policy == 0'u32

  test "chain.handle roundtrip":
    var c = Chain.create()
    c.handle = 99999'u64
    check c.handle == 99999'u64

  test "chain.userdata roundtrip":
    var c = Chain.create()
    c.userdata = "u-data"
    check c.userdata == "u-data"
</file>

<file path="tests/core_expr.nim">
discard """
action: "run"
"""

import unittest2 as unittest
import harness

suite "nftnl expression basics":
  test "cmp attribute roundtrip":
    let e = CmpExpr.create()

    # Use real libnftnl constants
    e.sreg = 1'u32 # Source register NFT_REG_1
    e.op = NFT_CMP_EQ # Comparison operator "=="
    e.data = @[0x12'u8, 0x34'u8] # Two-byte blob for comparison

    check e.sreg == 1
    check e.op == NFT_CMP_EQ
    check e.data == @[0x12'u8, 0x34'u8]

  test "cmp greater-than operator":
    let e = CmpExpr.create()

    e.sreg = 2'u32
    e.op = NFT_CMP_GT # Comparison operator ">"
    e.data = @[0xFF'u8]

    check e.op == NFT_CMP_GT
    check e.data == @[0xFF'u8]
</file>

<file path="tests/core_raii.nim">
discard """
action: "run"
"""

import unittest2 as unittest
import harness

suite "nftnl RAII and move-only semantics":
  # Allocation
  test "Table alloc/free":
    var t = Table.create()
    check not t.raw.isNil

  test "Chain alloc/free":
    var c = Chain.create()
    check not c.raw.isNil

  test "Rule alloc/free":
    var r = Rule.create()
    check not r.raw.isNil

  test "Set alloc/free":
    var s = Set.create()
    check not s.raw.isNil

  test "CmpExpr alloc/free":
    let e = CmpExpr.create()
    check not e.raw.isNil

  # Move semantics
  test "Table move transfers ownership":
    var t1 = Table.create()
    var t2 = move t1
    check t1.raw.isNil
    check not t2.raw.isNil

  test "Chain move transfers ownership":
    var c1 = Chain.create()
    var c2 = move c1
    check c1.raw.isNil
    check not c2.raw.isNil

  test "Rule move transfers ownership":
    var r1 = Rule.create()
    var r2 = move r1
    check r1.raw.isNil
    check not r2.raw.isNil

  test "Set move transfers ownership":
    var s1 = Set.create()
    var s2 = move s1
    check s1.raw.isNil
    check not s2.raw.isNil

  test "CmpExpr move transfers ownership":
    var e1 = CmpExpr.create()
    var e2 = move e1
    check e1.raw.isNil
    check not e2.raw.isNil

  # Scope exit (no double free)
  test "Move temporary Table then scope-exit frees cleanly":
    var t2: Table
    block:
      var t1 = Table.create()
      t2 = move t1
      check not t2.raw.isNil
      check t1.raw.isNil
    check not t2.raw.isNil
</file>

<file path="tests/core_rule.nim">
discard """
action: "run"
"""

import unittest2 as unittest
import harness

suite "nftnl Rule RAII and props":
  # Allocation / Freeing
  test "Rule alloc/free":
    var r = Rule.create()
    check not r.raw.isNil

  # Move semantics
  test "Rule move transfers ownership":
    var r1 = Rule.create()
    var r2 = move r1
    check r1.raw.isNil
    check not r2.raw.isNil

  # Property setters/getters
  test "Rule basic properties":
    var r = Rule.create()
    r.family = AF_INET.uint32
    r.table = "filter"
    r.chain = "input"

    check r.family == AF_INET.uint32
    check r.table == "filter"
    check r.chain == "input"

  # Ensure userdata roundtrip works
  test "Rule userdata property":
    var r = Rule.create()
    r.userdata = "customdata"
    check r.userdata == "customdata"
</file>

<file path="tests/core_table.nim">
discard """
action: "run"
"""

import unittest2 as unittest
import harness

suite "nftnl table props typing (runtime)":
  test "string props roundtrip":
    var t = Table.create()
    t.name = "roundtrip"
    check t.name == "roundtrip"

  test "uint32 props roundtrip":
    var t = Table.create()
    t.family = AF_INET
    check t.family == AF_INET

  test "uint64 props roundtrip":
    var t = Table.create()
    t.handle = 12345'u64
    check t.handle == 12345'u64

suite "nftnl table props sugar":
  test "table.name roundtrip":
    var t = Table.create()
    t.name = "viaProps"
    check t.name == "viaProps"

  test "table.family roundtrip":
    var t = Table.create()
    t.family = AF_INET
    check t.family == AF_INET

  test "table.flags roundtrip":
    var t = Table.create()
    t.flags = 7'u32
    check t.flags == 7'u32

  test "table.handle roundtrip":
    var t = Table.create()
    t.handle = 99999'u64
    check t.handle == 99999'u64

  test "table.userdata roundtrip":
    var t = Table.create()
    t.userdata = "u-data"
    check t.userdata == "u-data"
</file>

<file path="tests/integration_build.nim">
discard
  """
action: "run"
"""

import unittest2 as unittest
import harness

suite "libnet integration test":
  test "build table+base chain+rule+expr into nlmsg and pretty-print":
    # Step 1: construct a table
    var t = Table.create()
    t.family = AF_INET
    t.name = "filter"

    # Step 2: construct a **base chain**
    var c = Chain.create()
    c.family = AF_INET
    c.table = "filter"
    c.name = "input"
    c.typeName = "filter"
    c.hooknum = NF_INET_LOCAL_IN.uint32
    c.prio = 0'u32
    c.policy = NF_ACCEPT

    # Step 3: construct a rule
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    # Step 4: add a cmp expression (sreg == 0x1234)
    var e = CmpExpr.create()
    e.sreg = 1'u32
    e.op = NFT_CMP_EQ
    e.data = @[0x12'u8, 0x34'u8]
    addExpr(r, move e) # move, so no copy/double free

    # Step 5: prepare nlmsg buffer
    let seq = 1'u32
    let nlh =
      newNlMsg(NFT_MSG_NEWRULE.cint, AF_INET.cint, NLM_F_CREATE or NLM_F_ACK, seq)

    # Step 6: build payload from rule
    buildRuleMsg(nlh, r)

    # Step 7: pretty-print with snprintf
    var buf = newString(4096)
    let written = nftnl_rule_snprintf(
      cast[ptr uint8](buf.cstring),
      buf.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written > 0
    #echo ""
    #echo buf[0 ..< written]
    #echo ""
</file>

<file path="tests/integration_expr.nim">
discard
  """
action: "run"
"""

import unittest2 as unittest
import harness

suite "Expressions integration (payload / cmp / meta / bitwise)":
  test "payload + cmp: builds payload + cmp chain into rule and prints":
    # --- Table ---
    var t = Table.create()
    t.family = AF_INET
    t.name = "filter"

    # --- Base chain ---
    var c = Chain.create()
    c.family = AF_INET
    c.table = "filter"
    c.name = "input"
    c.typeName = "filter"
    c.hooknum = NF_INET_LOCAL_IN.uint32
    c.prio = 0'u32
    c.policy = NF_ACCEPT.uint32

    # --- Rule ---
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    # --- Payload expression ---
    var pexpr = PayloadExpr.create()
    pexpr.base = NFT_PAYLOAD_LL_HEADER.uint32
    pexpr.offset = 12
    pexpr.len = 2
    pexpr.dreg = NFT_REG_1.uint32
    addExpr(r, move pexpr)

    # --- Comparison expression: EtherType == 0x0800 (IPv4) ---
    var e = CmpExpr.create()
    e.sreg = NFT_REG_1.uint32
    e.op = NFT_CMP_EQ
    e.data = @[0x08'u8, 0x00'u8]
    addExpr(r, move e)

    # --- Build and pretty-print rule ---
    let nlh = newRuleNlMsg(1'u32)
    buildRuleMsg(nlh, r)

    var buf = newString(4096)
    let written = nftnl_rule_snprintf(
      cast[ptr uint8](buf.cstring),
      buf.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written > 0

  test "meta expression: load mark into reg and compare":
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    var m = MetaExpr.create()
    m.key = NFT_META_MARK.uint32
    m.dreg = NFT_REG_1.uint32
    addExpr(r, move m)

    var c = CmpExpr.create()
    c.sreg = NFT_REG_1.uint32
    c.op = NFT_CMP_EQ
    c.data = @[0x01'u8, 0x00'u8, 0x00'u8, 0x00'u8]
    addExpr(r, move c)

    let nlh2 = newRuleNlMsg(2'u32)
    buildRuleMsg(nlh2, r)

    var buf2 = newString(4096)
    let written2 = nftnl_rule_snprintf(
      cast[ptr uint8](buf2.cstring),
      buf2.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written2 > 0

  test "bitwise expression: mask/xor on payload-loaded register":
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    var p = PayloadExpr.create()
    p.base = NFT_PAYLOAD_LL_HEADER.uint32
    p.offset = 12
    p.len = 2
    p.dreg = NFT_REG_1.uint32
    addExpr(r, move p)

    var bexpr = BitwiseExpr.create()
    bexpr.sreg = NFT_REG_1.uint32
    bexpr.dreg = NFT_REG_1.uint32
    bexpr.len = 2'u32
    bexpr.mask = @[0xff'u8, 0x00'u8]
    bexpr.xor = @[0x01'u8, 0x00'u8]
    addExpr(r, move bexpr)

    var c = CmpExpr.create()
    c.sreg = NFT_REG_1.uint32
    c.op = NFT_CMP_EQ
    c.data = @[0x08'u8, 0x00'u8]
    addExpr(r, move c)

    let nlh3 = newRuleNlMsg(3'u32)
    buildRuleMsg(nlh3, r)

    var buf3 = newString(4096)
    let written3 = nftnl_rule_snprintf(
      cast[ptr uint8](buf3.cstring),
      buf3.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written3 > 0

  test "immediate verdict expression builds correctly":
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    var imm = ImmediateExpr.create()
    imm.verdict = NF_DROP.uint32
    addExpr(r, move imm)

    let nlh4 = newRuleNlMsg(10'u32)
    buildRuleMsg(nlh4, r)

    var buf4 = newString(4096)
    let written4 = nftnl_rule_snprintf(
      cast[ptr uint8](buf4.cstring),
      buf4.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written4 > 0

  test "counter expression: count packets and bytes, then jump on threshold":
    var r = Rule.create()
    r.family = AF_INET
    r.table = "filter"
    r.chain = "input"

    var ctr = CounterExpr.create()
    addExpr(r, move ctr)

    var imm = ImmediateExpr.create()
    imm.verdict = NF_ACCEPT.uint32
    addExpr(r, move imm)

    let nlh5 = newRuleNlMsg(4'u32)
    buildRuleMsg(nlh5, r)

    var buf5 = newString(4096)
    let written5 = nftnl_rule_snprintf(
      cast[ptr uint8](buf5.cstring),
      buf5.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written5 > 0
</file>

<file path="tests/integration_log.nim">
import ../harness/export_fuzz

# sanity test
fileEcho("hello from Nim fuzz harness")
echo "Wrote to /tmp/nim_fuzz.log"
</file>

<file path="tests/integration_mapping.nim">
import unittest
import ../harness/proto_raw as pb
import harness

suite "Mapping conversions from Protobuf â†’ nftnl":
  test "table â†’ chain â†’ rule prints correctly":
    var rule = pb.Rule(family: AF_INET.uint32, table: "filter", chain: "input")
    var chain =
      pb.Chain(family: AF_INET.uint32, table: "filter", name: "input", rules: @[rule])
    var table = pb.Table(family: AF_INET.uint32, name: "filter", chains: @[chain])
    var top = pb.Top(tables: @[table])

    echo "---- Running buildTop() ----"
    discard buildTop(top)
    echo "---- Done ----"

  test "table with mixed expressions prints detailed mapping (payload/cmp/meta/bitwise/immediate/ct)":
    # --- Payload expression (with checksum fields set) ---
    let payloadExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_PAYLOAD,
      dreg: 2'u32,
      base: 1'u32,
      offset: 0x20'u32,
      len: 4'u32,
      csum_type: 1'u32,
      csum_offset: 2'u32,
      csum_flags: 0x3'u32,
    )

    # --- Compare expression ---
    let cmpExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_CMP,
      sreg: 1'u32,
      op: 0x1'u32,
      data: @[0xde'u8, 0xad'u8, 0xbe'u8, 0xef'u8],
    )

    # --- Metadata expression ---
    let metaExpr = pb.Expr(`type`: pb.ExprType.EXPR_META, key: 1'u32, dreg: 1'u32)

    # --- Bitwise expression ---
    let bitwiseExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_BITWISE,
      sreg: 1'u32,
      dreg: 1'u32,
      op: 1'u32,
      len: 2'u32,
      mask: @[0xff'u8, 0x00'u8],
      `xor`: @[0x01'u8, 0x00'u8],
    )

    # --- Immediate expressions (data + verdict variants) ---
    let immDataExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_IMMEDIATE,
      dreg: 1'u32,
      data: @[0x01'u8, 0x02'u8, 0x03'u8],
    )

    let immVerdictExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_IMMEDIATE,
      verdict: NF_ACCEPT.uint32,
      chain: "next_chain",
      chain_id: 42'u32,
    )

    # --- Conntrack expression (newly added) ---
    let conntrackExpr = pb.Expr(
      `type`: pb.ExprType.EXPR_CT,
      key: 5'u32, # e.g., NFT_CT_STATE
      dreg: 2'u32, # destination register
      op: 1'u32, # direction (e.g., ORIGINAL)
    )

    # --- Rule containing all expressions ---
    let rule = pb.Rule(
      family: AF_INET.uint32,
      table: "filter",
      chain: "input",
      exprs:
        @[
          payloadExpr, cmpExpr, metaExpr, bitwiseExpr, immDataExpr, immVerdictExpr,
          conntrackExpr,
        ],
    )

    # --- Chain + Table nesting ---
    let chain =
      pb.Chain(family: AF_INET.uint32, table: "filter", name: "input", rules: @[rule])

    let table = pb.Table(family: AF_INET.uint32, name: "filter", chains: @[chain])

    let top = pb.Top(tables: @[table])

    echo "---- Running buildTop() with payload + cmp + meta + bitwise + immediate + ct ----"
    discard buildTop(top)
    echo "---- Done ----"
</file>

<file path="tests/integration_sanitize.nim">
import unittest
import ../harness/export_fuzz as fuzz
import ../harness/proto_raw as pb
import std/[sequtils, strutils]
import protobuf_serialization

suite "sanitizeTop() and run_from_pb() integration":
  test "sanitizeTop fills defaults for minimal protobuf":
    var top = pb.Top(
      tables:
        @[
          pb.Table(
            family: 0,
            name: "",
            chains:
              @[
                pb.Chain(
                  family: 0,
                  table: "",
                  name: "",
                  `type`: "",
                  hook: 0,
                  prio: 99999'i32,
                  policy: 42'u32,
                  rules:
                    @[
                      pb.Rule(
                        family: 0,
                        table: "",
                        chain: "",
                        exprs:
                          @[
                            pb.Expr(
                              `type`: 1,
                              payload:
                                pb.ExprPayload(dreg: 0, base: 0, offset: 0, len: 0),
                            ),
                            pb.Expr(
                              `type`: 2, cmp: pb.ExprCmp(sreg: 0, op: 0, data: @[])
                            ),
                          ],
                      )
                    ],
                )
              ],
          )
        ]
    )

    fuzz.sanitizeTop(top)

    let t = top.tables[0]
    check t.name == "filter"
    check t.family == 2 # AF_INET default
    let c = t.chains[0]
    check c.table == "filter"
    check c.name == "input"
    check c.`type` == "filter"
    check c.hook == 1
    check c.policy == 1'u32
    check c.rules.len == 1

    let r = c.rules[0]
    check r.table == "filter"
    check r.chain == "input"
    check r.family == 2
    check r.exprs.len == 2

    let payload = r.exprs[0]
    let cmp = r.exprs[1]
    check payload.payload.len == 0
    check cmp.cmp.data.len == 2
    check cmp.cmp.data == @[0x12'u8, 0x34'u8]

  test "run_from_pb handles valid Top input end-to-end":
    let top = pb.Top(
      tables:
        @[
          pb.Table(
            family: 2,
            name: "filter",
            chains:
              @[
                pb.Chain(
                  family: 2,
                  table: "filter",
                  name: "input",
                  `type`: "filter",
                  hook: 1,
                  prio: 0,
                  policy: 1'u32,
                  rules: @[pb.Rule(family: 2, table: "filter", chain: "input")],
                )
              ],
          )
        ]
    )

    let data = Protobuf.encode(top)
    let result = fuzz.run_from_pb(unsafeAddr data[0], data.len.csize_t)
    check result == 0
</file>

<file path="tests/integration_snprintf.nim">
discard
  """
action: "run"
"""

import unittest2 as unittest
import harness

suite "libnet smoke test":
  test "table pretty-prints":
    var t = Table.create()
    t.family = AF_INET
    t.name = "filter"
    var buf = newString(512)
    let written = nftnl_table_snprintf(
      cast[ptr uint8](buf.cstring),
      buf.len.csize_t,
      t.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written > 0
    #echo ""
    #echo buf[0 ..< written]
    #echo ""

  test "chain pretty-prints":
    var c = Chain.create()
    c.family = AF_INET
    c.table = "filter"
    c.name = "input"
    c.typeName = "filter"
    c.hooknum = NF_INET_LOCAL_IN.uint32
    c.prio = 0'u32
    c.policy = NF_ACCEPT.uint32
    var buf = newString(512)
    let written = nftnl_chain_snprintf(
      cast[ptr uint8](buf.cstring),
      buf.len.csize_t,
      c.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written > 0
    #echo ""
    #echo buf[0 ..< written]
    #echo ""

  test "rule with simple cmp expr pretty-prints":
    var r = Rule.create()
    r.family = AF_INET.uint32
    r.table = "filter"
    r.chain = "input"
    var e = CmpExpr.create()
    e.sreg = 1'u32
    e.op = NFT_CMP_EQ
    e.data = @[0x12'u8, 0x34'u8]
    addExpr(r, move(e))
    var buf = newString(1024)
    let written = nftnl_rule_snprintf(
      cast[ptr uint8](buf.cstring),
      buf.len.csize_t,
      r.raw,
      NFTNL_OUTPUT_DEFAULT.uint32,
      0'u32,
    )
    check written > 0
    #echo ""
    #echo buf[0 ..< written]
    #echo ""
</file>

<file path="tests/test_all.nim">
import std/[macros, os, strutils]

macro importAllTests(dir: static[string]) =
  result = newStmtList()
  for kind, path in walkDir(dir):
    if kind == pcFile and path.endsWith(".nim"):
      let fname = splitFile(path).name
      if fname == "test_all":
        continue
      result.add quote do:
        import `fname`

importAllTests("tests")
</file>

<file path="tests/test_core.nim">
import std/[macros, os, strutils]

macro importTestsWithPrefix(dir: static[string], prefix: static[string]) =
  result = newStmtList()
  for kind, path in walkDir(dir):
    if kind == pcFile and path.endsWith(".nim"):
      let fname = splitFile(path).name
      if fname == "test_all" or not fname.startsWith(prefix):
        continue
      result.add quote do:
        import `fname`

importTestsWithPrefix("tests", "core_")
</file>

<file path="tests/test_integration.nim">
import std/[macros, os, strutils]

macro importTestsWithPrefix(dir: static[string], prefix: static[string]) =
  result = newStmtList()
  for kind, path in walkDir(dir):
    if kind == pcFile and path.endsWith(".nim"):
      let fname = splitFile(path).name
      if fname == "test_all" or not fname.startsWith(prefix):
        continue
      result.add quote do:
        import `fname`

importTestsWithPrefix("tests", "integration_")
</file>

<file path=".gitignore">
# ------------------------------
# Build & compilation artifacts
# ------------------------------
/build/
/CMakeFiles/
/CMakeCache.txt
/Makefile
/cmake_install.cmake
/compile_commands.json

# --- Perf / Flamegraph artifacts ---
perf.data
perf.data.*
out.folded
flame.svg


# Protobuf generated sources
*.pb.cc
*.pb.h

# Object files, binaries, libraries
*.o
*.obj
*.lo
*.a
*.so
*.dylib
*.dll
*.exe

# Fuzzer and crash artifacts
crash-*
leak-*
timeout-*
corpus/
default.profraw
*.log

# ------------------------------
# Nim build artifacts
# ------------------------------
nimcache/
*.exe
*.out
*.bin

# Nimble package manager
.nimble/
*.nimble-cache/

# ------------------------------
# Editor & tooling
# ------------------------------
.idea/
.vscode/
.DS_Store
*.swp
*.swo
*.bak

# Zed, Xonsh, etc.
.zed/
xonsh_history
xonshrc

# ------------------------------
# Nix / flake artifacts
# ------------------------------
result
result-*
.direnv/
.cache/
saved_corpus/

# Ignore fuzz artifacts
saved_corpus/
crash-*
timeout-*
leak-*
out.folded
**/autogenerated/*
</file>

<file path="devshells.nix">
{ inputs, cell }:
let
  pkgs = inputs.nixpkgs;
  llvm = pkgs.llvmPackages_21;
  fenv = inputs.cells.nix.lib.fuzzerEnv;

in
{
  default = llvm.libcxxStdenv.mkDerivation {
    name = "libnet-std-env";
    dontUnpack = true;
    dontBuild = true;

    buildInputs =
      fenv.toolchain.nativeBuildInputs
      ++ fenv.toolchain.buildInputs
      ++ [
        cell.installables.default
      ];

    shellHook = ''
      export PATH="$HOME/.nimble/bin:$PATH"
      echo "ðŸ”¨ Welcome to libnet (LLVM devshell)"
      echo
    '';
  };
}
</file>

<file path="harness.nimble">
# Package

version = "0.1.0"
author = "Anonymous"
description = "A new awesome nimble package"
license = "MIT"
srcDir = "src"

# Dependencies

requires "nim >= 2.2.4"
requires "futhark >= 0.15.0"
requires "https://github.com/status-im/nim-protobuf-serialization"
</file>

<file path="installables.nix">
{ inputs, cell, ... }:

let
  pkgs = inputs.nixpkgs;
  fenv = inputs.cells.nix.lib.fuzzerEnv;

  libprotobuf-mutator = inputs.cells.nix.lib.lpm;

  # Use same LLVM as fenv
  stdenv = fenv.toolchain.stdenv;

  nimDeps = [
    inputs.protobuf_serialization
    inputs.serialization
    inputs.stew
    inputs.faststreams
    inputs.unittest2
    inputs.protobuf_npeg
  ];
  # Convert list â†’ single string of --passL=... arguments
  passLFlags = builtins.concatStringsSep " " (map (f: "--passL=" + f) fenv.toolchain.rpathFlags);

in
{
  default = stdenv.mkDerivation {
    pname = "libnet-fuzzer";
    version = "0.1.0";
    src = inputs.self + "/src/fuzzer";

    dontUseCmake = true;

    nativeBuildInputs = fenv.toolchain.nativeBuildInputs;
    buildInputs = fenv.toolchain.buildInputs;

    configurePhase = ''
      ${fenv.toolchain.shellEnvHook}
      export NIX_NIM_BUILD_INPUTS="${toString nimDeps} $NIX_NIM_BUILD_INPUTS"

      echo "ðŸ”¹ Nim â†’ configure"
      nim_builder --phase:configure
    '';

    buildPhase = ''
      ${fenv.toolchain.shellEnvHook}

      echo "PASS L FLAGS: ${passLFlags}"


      mkdir -p build
      echo "ðŸ”¹ Nim â†’ build/libnetfuzz.so"
      nim c \
        --cc:clang \
        --app:lib \
        --mm:orc --threads:on \
        --debuginfo:on --lineTrace:on --stackTrace:on --assertions:on \
        --passC:"-fPIC" \
        --passL:"-fuse-ld=lld" \
        ${passLFlags} \
        --out:build/libnetfuzz.so \
        harness/export_fuzz.nim
    '';

    installPhase = ''
      ${fenv.toolchain.shellEnvHook}
      runHook preInstall

      mkdir -p build

      echo "ðŸ”¹ protoc â†’ elaborate.pb.cc"
      ${pkgs.protobuf}/bin/protoc \
        --proto_path=schema \
        --cpp_out=build \
        schema/elaborate.proto

      echo "ðŸ”¹ compile C++ fuzz parts"
      $CXX -std=c++20 -fPIC \
        $(pkg-config --cflags protobuf libprotobuf-mutator) \
        -Isrc -Ibuild \
        -c build/elaborate.pb.cc -o build/elaborate.pb.o

      $CXX -std=c++20 -fPIC \
        $(pkg-config --cflags protobuf libprotobuf-mutator) \
        -Isrc -Ibuild \
        -c mutator/lpm_consumer.cpp -o build/fuzz.o

      PC_LIBS="$(pkg-config --libs protobuf libprotobuf-mutator | xargs echo)"

      echo "ðŸ”¹ link lpm-consumer-fuzz with coverage-instrumented libs"
      $CXX -o build/lpm-consumer-fuzz \
        build/fuzz.o build/elaborate.pb.o \
        -Lbuild -lnetfuzz \
        -L${fenv.toolchain.libnftnlCov}/lib -lnftnl \
        -L${fenv.toolchain.libmnlCov}/lib -lmnl \
        $PC_LIBS \
        -fsanitize=fuzzer,address,undefined \
        -fprofile-instr-generate -fcoverage-mapping \
        -lunwind -ldl -pthread \
        -Wl,--whole-archive "${fenv.toolchain.profileRt}" -Wl,--no-whole-archive \
        -Wl,-rpath,'$ORIGIN' \
        -Wl,-rpath,${fenv.toolchain.libnftnlCov}/lib \
        -Wl,-rpath,${fenv.toolchain.libmnlCov}/lib \
        -Wl,-rpath,${libprotobuf-mutator}/lib \
        -Wl,-rpath,${pkgs.protobuf}/lib \
        -Wl,-rpath,${pkgs.libunwind}/lib \
        -Wl,-rpath,${fenv.toolchain.profileRt} \
        -Wl,-rpath,${stdenv.cc.libc}/lib \
        -Wl,--enable-new-dtags

      mkdir -p "$out/bin"
      cp build/lpm-consumer-fuzz "$out/bin/"
      cp build/libnetfuzz.so     "$out/bin/"
      runHook postInstall
    '';

    checkPhase = "echo skipping checks";
    meta.mainProgram = "lpm-consumer-fuzz";
  };
}
</file>

</files>
