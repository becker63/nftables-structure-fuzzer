This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.nix
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
flake.nix
process-schedule.nix
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="process-schedule.nix">
{
  lib,
  stdExe,
  pkgs,
  ...
}:
{
  cli.options.port = 8213;

  settings.processes = {

    # ---------------------
    # metrics-exporter
    # ---------------------
    metrics_build = {
      command = ''${stdExe} //containers/containers/metrics-exporter:build'';
    };

    metrics_load = {
      command = ''${stdExe} //containers/containers/metrics-exporter:load'';
      depends_on.metrics_build.condition = "process_completed_successfully";
    };

    # ---------------------
    # prometheus (built locally)
    # ---------------------
    prometheus_build = {
      command = ''${stdExe} //containers/containers/prometheus:build'';
    };

    prometheus_load = {
      command = ''${stdExe} //containers/containers/prometheus:load'';
      depends_on.prometheus_build.condition = "process_completed_successfully";
    };

    # ---------------------
    # grafana (built locally)
    # ---------------------
    grafana_build = {
      command = ''${stdExe} //containers/containers/grafana:build'';
    };

    grafana_load = {
      command = ''${stdExe} //containers/containers/grafana:load'';
      depends_on.grafana_build.condition = "process_completed_successfully";
    };

    # ---------------------
    # Start containers
    # ---------------------
    containers_run = {
      command = ''${stdExe} //containers/compose/config:up'';
      depends_on.metrics_load.condition = "process_completed_successfully";
      depends_on.prometheus_load.condition = "process_completed_successfully";
      depends_on.grafana_load.condition = "process_completed_successfully";
    };

    virtIO_daemon_run = {
      command = ''${stdExe} //containers/script/default:run'';
      ready_log_line = "Waiting for vhost-user socket connection";
    };

    vm_run = {
      command = ''${stdExe} //containers/microvm/libnet-fuzz-vm:run'';
      depends_on.virtIO_daemon_run.condition = "process_log_ready";
      ready_log_line = "Run 'nixos-help' for the NixOS manual.";
    };

  };
}
</file>

<file path="flake.nix">
{
  description = "libnet using divnix/std with flake-parts root devshell";

  inputs = {

    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";

    # Force root-level nixpkgs to dominate all others
    std.url = "github:divnix/std";
    std.inputs.nixpkgs.follows = "nixpkgs";

    # Avoid std pulling its own nixpkgs
    std.inputs.devshell.url = "github:numtide/devshell";
    std.inputs.devshell.inputs.nixpkgs.follows = "nixpkgs";

    flake-root.url = "github:srid/flake-root";
    flake-root.inputs.nixpkgs.follows = "nixpkgs";

    std.inputs.microvm = {
      url = "github:microvm-nix/microvm.nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    n2c.url = "github:nlewo/nix2container";
    n2c.inputs.nixpkgs.follows = "nixpkgs";

    std.inputs.arion.url = "github:hercules-ci/arion";
    std.inputs.n2c.url = "github:nlewo/nix2container";

    process-compose-flake.url = "github:Platonic-Systems/process-compose-flake";

    libprotobuf-mutator = {
      url = "github:becker63/libprotobuf-mutator";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    # nim deps (all flake = false)
    nim_metrics = {
      url = "github:status-im/nim-metrics";
      flake = false;
    };
    chronos = {
      url = "github:status-im/nim-chronos";
      flake = false;
    };
    http-utils = {
      url = "github:status-im/nim-http-utils";
      flake = false;
    };
    results = {
      url = "github:arnetheduck/nim-results";
      flake = false;
    };
    protobuf_serialization = {
      url = "github:status-im/nim-protobuf-serialization";
      flake = false;
    };
    serialization = {
      url = "github:status-im/nim-serialization";
      flake = false;
    };
    stew = {
      url = "github:status-im/nim-stew";
      flake = false;
    };
    faststreams = {
      url = "github:status-im/nim-faststreams";
      flake = false;
    };
    unittest2 = {
      url = "github:status-im/nim-unittest2";
      flake = false;
    };
    protobuf_npeg = {
      url = "github:status-im/npeg/22449099";
      flake = false;
    };
  };

  outputs =
    inputs@{
      self,
      std,
      flake-parts,
      nixpkgs,
      ...
    }:
    let
      # âœ… define systems ONCE
      systems = [
        "x86_64-linux"
        "aarch64-linux"
      ];
    in
    with std;

    growOn
      {
        inherit inputs systems;
        cellsFrom = ./src;
        cellBlocks = [
          (blockTypes.installables "installables")
          (blockTypes.devshells "devshells")
          (blockTypes.containers "apps")
          (blockTypes.functions "lib")
          (blockTypes.microvms "microvm")
          (blockTypes.runnables "script")
          (blockTypes.containers "containers")
          (blockTypes.arion "compose")
        ];
      }

      # âœ… flake-parts root devshell, also using shared `systems`
      (
        flake-parts.lib.mkFlake { inherit inputs; } {

          inherit systems;
          imports = [
            inputs.process-compose-flake.flakeModule
            inputs.flake-root.flakeModule
          ];

          perSystem =
            {
              system,
              pkgs,
              lib,
              ...
            }:
            let
              pkgs = nixpkgs.legacyPackages.${system};

              stdExe = lib.getExe inputs.std.packages.${system}.std;

              processComposeSpec = import ./process-schedule.nix {
                inherit lib stdExe pkgs;
              };
            in
            {
              devShells.default = pkgs.mkShell {
                name = "libnet-root-std-shell";
                packages = [
                  inputs.std.packages.${system}.std
                ];
                shellHook = ''
                  echo "ðŸ§¬ Launching libnet std environment for ${system}"
                  echo "Type 'exit' to leave std"

                  USER_SHELL=$(getent passwd "$USER" | cut -d: -f7)
                  [ -n "$USER_SHELL" ] && export SHELL="$USER_SHELL"

                  exec std
                '';
              };

              process-compose.default = processComposeSpec;

            };
        }
      );
}
</file>

</files>
